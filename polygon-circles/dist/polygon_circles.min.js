(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.polygon_circles=f()}})(function(){var define,module,exports;var _$main_4={};"use strict";Object.defineProperty(_$main_4,"__esModule",{value:true});var earthRadius=6371008.8;var factors={meters:earthRadius,metres:earthRadius,millimeters:earthRadius*1e3,millimetres:earthRadius*1e3,centimeters:earthRadius*100,centimetres:earthRadius*100,kilometers:earthRadius/1e3,kilometres:earthRadius/1e3,miles:earthRadius/1609.344,nauticalmiles:earthRadius/1852,inches:earthRadius*39.37,yards:earthRadius/1.0936,feet:earthRadius*3.28084,radians:1,degrees:earthRadius/111325};var unitsFactors={meters:1,metres:1,millimeters:1e3,millimetres:1e3,centimeters:100,centimetres:100,kilometers:1/1e3,kilometres:1/1e3,miles:1/1609.344,nauticalmiles:1/1852,inches:39.37,yards:1/1.0936,feet:3.28084,radians:1/earthRadius,degrees:1/111325};var areaFactors={meters:1,metres:1,millimeters:1e6,millimetres:1e6,centimeters:1e4,centimetres:1e4,kilometers:1e-6,kilometres:1e-6,acres:247105e-9,miles:3.86e-7,yards:1.195990046,feet:10.763910417,inches:1550.003100006};function feature(geometry,properties,options){options=options||{};if(!isObject(options))throw new Error("options is invalid");var bbox=options.bbox;var id=options.id;if(geometry===undefined)throw new Error("geometry is required");if(properties&&properties.constructor!==Object)throw new Error("properties must be an Object");if(bbox)validateBBox(bbox);if(id)validateId(id);var feat={type:"Feature"};if(id)feat.id=id;if(bbox)feat.bbox=bbox;feat.properties=properties||{};feat.geometry=geometry;return feat}function geometry(type,coordinates,options){options=options||{};if(!isObject(options))throw new Error("options is invalid");var bbox=options.bbox;if(!type)throw new Error("type is required");if(!coordinates)throw new Error("coordinates is required");if(!Array.isArray(coordinates))throw new Error("coordinates must be an Array");if(bbox)validateBBox(bbox);var geom;switch(type){case"Point":geom=point(coordinates).geometry;break;case"LineString":geom=lineString(coordinates).geometry;break;case"Polygon":geom=polygon(coordinates).geometry;break;case"MultiPoint":geom=multiPoint(coordinates).geometry;break;case"MultiLineString":geom=multiLineString(coordinates).geometry;break;case"MultiPolygon":geom=multiPolygon(coordinates).geometry;break;default:throw new Error(type+" is invalid")}if(bbox)geom.bbox=bbox;return geom}function point(coordinates,properties,options){if(!coordinates)throw new Error("coordinates is required");if(!Array.isArray(coordinates))throw new Error("coordinates must be an Array");if(coordinates.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!isNumber(coordinates[0])||!isNumber(coordinates[1]))throw new Error("coordinates must contain numbers");return feature({type:"Point",coordinates:coordinates},properties,options)}function points(coordinates,properties,options){if(!coordinates)throw new Error("coordinates is required");if(!Array.isArray(coordinates))throw new Error("coordinates must be an Array");return featureCollection(coordinates.map(function(coords){return point(coords,properties)}),options)}function polygon(coordinates,properties,options){if(!coordinates)throw new Error("coordinates is required");for(var i=0;i<coordinates.length;i++){var ring=coordinates[i];if(ring.length<4){throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.")}for(var j=0;j<ring[ring.length-1].length;j++){if(i===0&&j===0&&!isNumber(ring[0][0])||!isNumber(ring[0][1]))throw new Error("coordinates must contain numbers");if(ring[ring.length-1][j]!==ring[0][j]){throw new Error("First and last Position are not equivalent.")}}}return feature({type:"Polygon",coordinates:coordinates},properties,options)}function polygons(coordinates,properties,options){if(!coordinates)throw new Error("coordinates is required");if(!Array.isArray(coordinates))throw new Error("coordinates must be an Array");return featureCollection(coordinates.map(function(coords){return polygon(coords,properties)}),options)}function lineString(coordinates,properties,options){if(!coordinates)throw new Error("coordinates is required");if(coordinates.length<2)throw new Error("coordinates must be an array of two or more positions");if(!isNumber(coordinates[0][1])||!isNumber(coordinates[0][1]))throw new Error("coordinates must contain numbers");return feature({type:"LineString",coordinates:coordinates},properties,options)}function lineStrings(coordinates,properties,options){if(!coordinates)throw new Error("coordinates is required");if(!Array.isArray(coordinates))throw new Error("coordinates must be an Array");return featureCollection(coordinates.map(function(coords){return lineString(coords,properties)}),options)}function featureCollection(features,options){options=options||{};if(!isObject(options))throw new Error("options is invalid");var bbox=options.bbox;var id=options.id;if(!features)throw new Error("No features passed");if(!Array.isArray(features))throw new Error("features must be an Array");if(bbox)validateBBox(bbox);if(id)validateId(id);var fc={type:"FeatureCollection"};if(id)fc.id=id;if(bbox)fc.bbox=bbox;fc.features=features;return fc}function multiLineString(coordinates,properties,options){if(!coordinates)throw new Error("coordinates is required");return feature({type:"MultiLineString",coordinates:coordinates},properties,options)}function multiPoint(coordinates,properties,options){if(!coordinates)throw new Error("coordinates is required");return feature({type:"MultiPoint",coordinates:coordinates},properties,options)}function multiPolygon(coordinates,properties,options){if(!coordinates)throw new Error("coordinates is required");return feature({type:"MultiPolygon",coordinates:coordinates},properties,options)}function geometryCollection(geometries,properties,options){if(!geometries)throw new Error("geometries is required");if(!Array.isArray(geometries))throw new Error("geometries must be an Array");return feature({type:"GeometryCollection",geometries:geometries},properties,options)}function round(num,precision){if(num===undefined||num===null||isNaN(num))throw new Error("num is required");if(precision&&!(precision>=0))throw new Error("precision must be a positive number");var multiplier=Math.pow(10,precision||0);return Math.round(num*multiplier)/multiplier}function radiansToLength(radians,units){if(radians===undefined||radians===null)throw new Error("radians is required");if(units&&typeof units!=="string")throw new Error("units must be a string");var factor=factors[units||"kilometers"];if(!factor)throw new Error(units+" units is invalid");return radians*factor}function lengthToRadians(distance,units){if(distance===undefined||distance===null)throw new Error("distance is required");if(units&&typeof units!=="string")throw new Error("units must be a string");var factor=factors[units||"kilometers"];if(!factor)throw new Error(units+" units is invalid");return distance/factor}function lengthToDegrees(distance,units){return radiansToDegrees(lengthToRadians(distance,units))}function bearingToAzimuth(bearing){if(bearing===null||bearing===undefined)throw new Error("bearing is required");var angle=bearing%360;if(angle<0)angle+=360;return angle}function radiansToDegrees(radians){if(radians===null||radians===undefined)throw new Error("radians is required");var degrees=radians%(2*Math.PI);return degrees*180/Math.PI}function degreesToRadians(degrees){if(degrees===null||degrees===undefined)throw new Error("degrees is required");var radians=degrees%360;return radians*Math.PI/180}function convertLength(length,originalUnit,finalUnit){if(length===null||length===undefined)throw new Error("length is required");if(!(length>=0))throw new Error("length must be a positive number");return radiansToLength(lengthToRadians(length,originalUnit),finalUnit||"kilometers")}function convertArea(area,originalUnit,finalUnit){if(area===null||area===undefined)throw new Error("area is required");if(!(area>=0))throw new Error("area must be a positive number");var startFactor=areaFactors[originalUnit||"meters"];if(!startFactor)throw new Error("invalid original units");var finalFactor=areaFactors[finalUnit||"kilometers"];if(!finalFactor)throw new Error("invalid final units");return area/startFactor*finalFactor}function isNumber(num){return!isNaN(num)&&num!==null&&!Array.isArray(num)}function isObject(input){return!!input&&input.constructor===Object}function validateBBox(bbox){if(!bbox)throw new Error("bbox is required");if(!Array.isArray(bbox))throw new Error("bbox must be an Array");if(bbox.length!==4&&bbox.length!==6)throw new Error("bbox must be an Array of 4 or 6 numbers");bbox.forEach(function(num){if(!isNumber(num))throw new Error("bbox must only contain numbers")})}function validateId(id){if(!id)throw new Error("id is required");if(["string","number"].indexOf(typeof id)===-1)throw new Error("id must be a number or a string")}function radians2degrees(){throw new Error("method has been renamed to `radiansToDegrees`")}function degrees2radians(){throw new Error("method has been renamed to `degreesToRadians`")}function distanceToDegrees(){throw new Error("method has been renamed to `lengthToDegrees`")}function distanceToRadians(){throw new Error("method has been renamed to `lengthToRadians`")}function radiansToDistance(){throw new Error("method has been renamed to `radiansToLength`")}function bearingToAngle(){throw new Error("method has been renamed to `bearingToAzimuth`")}function convertDistance(){throw new Error("method has been renamed to `convertLength`")}void earthRadius;void factors;void unitsFactors;void areaFactors;void feature;void geometry;_$main_4.point=point;void points;_$main_4.polygon=polygon;void polygons;void lineString;void lineStrings;void featureCollection;void multiLineString;void multiPoint;void multiPolygon;void geometryCollection;void round;void radiansToLength;_$main_4.lengthToRadians=lengthToRadians;void lengthToDegrees;void bearingToAzimuth;_$main_4.radiansToDegrees=radiansToDegrees;_$main_4.degreesToRadians=degreesToRadians;void convertLength;void convertArea;_$main_4.isNumber=isNumber;_$main_4.isObject=isObject;void validateBBox;void validateId;void radians2degrees;void degrees2radians;void distanceToDegrees;void distanceToRadians;void radiansToDistance;void bearingToAngle;void convertDistance;var _$main_5={};"use strict";Object.defineProperty(_$main_5,"__esModule",{value:true});function getCoord(coord){if(!coord)throw new Error("coord is required");if(coord.type==="Feature"&&coord.geometry!==null&&coord.geometry.type==="Point")return coord.geometry.coordinates;if(coord.type==="Point")return coord.coordinates;if(Array.isArray(coord)&&coord.length>=2&&coord[0].length===undefined&&coord[1].length===undefined)return coord;throw new Error("coord must be GeoJSON Point or an Array of numbers")}function getCoords(coords){if(!coords)throw new Error("coords is required");if(coords.type==="Feature"&&coords.geometry!==null)return coords.geometry.coordinates;if(coords.coordinates)return coords.coordinates;if(Array.isArray(coords))return coords;throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")}function containsNumber(coordinates){if(coordinates.length>1&&_$main_4.isNumber(coordinates[0])&&_$main_4.isNumber(coordinates[1])){return true}if(Array.isArray(coordinates[0])&&coordinates[0].length){return containsNumber(coordinates[0])}throw new Error("coordinates must only contain numbers")}function geojsonType(value,type,name){if(!type||!name)throw new Error("type and name required");if(!value||value.type!==type){throw new Error("Invalid input to "+name+": must be a "+type+", given "+value.type)}}function featureOf(feature,type,name){if(!feature)throw new Error("No feature passed");if(!name)throw new Error(".featureOf() requires a name");if(!feature||feature.type!=="Feature"||!feature.geometry){throw new Error("Invalid input to "+name+", Feature with geometry required")}if(!feature.geometry||feature.geometry.type!==type){throw new Error("Invalid input to "+name+": must be a "+type+", given "+feature.geometry.type)}}function collectionOf(featureCollection,type,name){if(!featureCollection)throw new Error("No featureCollection passed");if(!name)throw new Error(".collectionOf() requires a name");if(!featureCollection||featureCollection.type!=="FeatureCollection"){throw new Error("Invalid input to "+name+", FeatureCollection required")}for(var i=0;i<featureCollection.features.length;i++){var feature=featureCollection.features[i];if(!feature||feature.type!=="Feature"||!feature.geometry){throw new Error("Invalid input to "+name+", Feature with geometry required")}if(!feature.geometry||feature.geometry.type!==type){throw new Error("Invalid input to "+name+": must be a "+type+", given "+feature.geometry.type)}}}function getGeom(geojson){if(!geojson)throw new Error("geojson is required");if(geojson.geometry!==undefined)return geojson.geometry;if(geojson.coordinates||geojson.geometries)return geojson;throw new Error("geojson must be a valid Feature or Geometry Object")}function getGeomType(){throw new Error("invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType")}function getType(geojson,name){if(!geojson)throw new Error((name||"geojson")+" is required");if(geojson.geometry&&geojson.geometry.type)return geojson.geometry.type;if(geojson.type)return geojson.type;throw new Error((name||"geojson")+" is invalid")}_$main_5.getCoord=getCoord;void getCoords;void containsNumber;void geojsonType;void featureOf;void collectionOf;void getGeom;void getGeomType;void getType;var _$main_3={};"use strict";function destination(origin,distance,bearing,options){options=options||{};if(!_$main_4.isObject(options))throw new Error("options is invalid");var units=options.units;var properties=options.properties;var coordinates1=_$main_5.getCoord(origin);var longitude1=_$main_4.degreesToRadians(coordinates1[0]);var latitude1=_$main_4.degreesToRadians(coordinates1[1]);var bearing_rad=_$main_4.degreesToRadians(bearing);var radians=_$main_4.lengthToRadians(distance,units);var latitude2=Math.asin(Math.sin(latitude1)*Math.cos(radians)+Math.cos(latitude1)*Math.sin(radians)*Math.cos(bearing_rad));var longitude2=longitude1+Math.atan2(Math.sin(bearing_rad)*Math.sin(radians)*Math.cos(latitude1),Math.cos(radians)-Math.sin(latitude1)*Math.sin(latitude2));var lng=_$main_4.radiansToDegrees(longitude2);var lat=_$main_4.radiansToDegrees(latitude2);return _$main_4.point([lng,lat],properties)}_$main_3=destination;_$main_3.default=destination;var _$main_2={};"use strict";function _interopDefault(ex){return ex&&typeof ex==="object"&&"default"in ex?ex["default"]:ex}var __destination_2=_interopDefault(_$main_3);function circle(center,radius,options){options=options||{};var steps=options.steps||64;var properties=options.properties;if(!center)throw new Error("center is required");if(!radius)throw new Error("radius is required");if(typeof options!=="object")throw new Error("options must be an object");if(typeof steps!=="number")throw new Error("steps must be a number");steps=steps||64;properties=properties||center.properties||{};var coordinates=[];for(var i=0;i<steps;i++){coordinates.push(__destination_2(center,radius,i*-360/steps,options).geometry.coordinates)}coordinates.push(coordinates[0]);return _$main_4.polygon([coordinates],properties)}_$main_2=circle;_$main_2.default=circle;function onInvoke(meta,getValue,setValue){var options={table:getValue("table"),latField:getValue("latField"),lngField:getValue("lngField"),radiusField:getValue("radiusField"),steps:parseFloat(getValue("steps")),radius:parseFloat(getValue("radius")),units:getValue("units"),addProperties:getValue("addProperties").toString()==="true"};var radiusScalar=1;if(!options.steps||isNaN(options.steps)){options.steps=64}if(!options.radius||isNaN(options.radius)){options.radius=.2}if(!options.units||!options.units.trim().length){options.units="kilometers"}if(options.units=="feet"){options.units="miles";radiusScalar/=5280}if(!options.table){console.error("polygon_circles: no table!");return}var latFieldIdx=-1;var lngFieldIdx=-1;var radiusFieldIdx=-1;var propertyNames=[];options.table.cols.forEach(function(col,i){if(col.name===options.latField){latFieldIdx=i}if(col.name===options.lngField){lngFieldIdx=i}if(options.radiusField&&col.name===options.radiusField){radiusFieldIdx=i}if(options.addProperties){propertyNames.push(col.name)}});if(latFieldIdx<0||lngFieldIdx<0){console.error("polygon_circles: invalid latField/lngField! "+latFieldIdx+" "+lngFieldIdx);return}var features=options.table.rows.map(function(row){var properties={};if(options.addProperties){propertyNames.forEach(function(name,i){if(i===lngFieldIdx||i==latFieldIdx||i==radiusFieldIdx){return}properties[name]=row[i]})}var coordinates=[parseFloat(row[lngFieldIdx]),parseFloat(row[latFieldIdx])];var radius=radiusFieldIdx<0?options.radius:parseFloat(row[radiusFieldIdx]);if(isNaN(radius)){radius=0}return _$main_2(coordinates,radius*radiusScalar,{steps:options.steps,units:options.units,properties:properties})});var geojson=JSON.stringify({type:"FeatureCollection",features:features});setValue("geojson",geojson)}var _$polygonCircles_1=function(){return onInvoke};return _$polygonCircles_1});
